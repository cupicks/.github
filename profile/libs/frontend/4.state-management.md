[< 뒤로가기](./README.md)

## 4. 상태 관리

```cmd
 4.1. 필요성
 4.2. 비교 대상 및 선택 동기
 4.3. 후기
```

<br>

> 초안은 더욱 다양한 내용을 가지고 있습니다. <br>
> 관련된 내용이 궁금하시다면, 다음 링크를 참고해주세요. <br>
> 초안 : [Notion/Cupick - React-Hook-Form](https://www.notion.so/5e458f2e19c544dc99651f3af3e59d9c#312e5ff3d8fc4a35a3547ca6044b2ef9)
> 초안 작성자 : -

<br>
<hr>

### 4.1. 필요성

Cupick 의 가장 큰 매력은 ***사용자가 자유롭게 만들 수 있는 레시피*** 입니다.

이러한 ***레시피는***, 1 개의 본문과 ***N 개의 세부 재료*** 항목으로 구성되었습니다. 안정적인 서비스 공급과 UX/UI 를 보장하기 위해서 다음과 같은 수많은 제약 조건을 확실하게 체크해야 했습니다.

```cmd
1. 레시피 제목 - 2 ~ 10 자리 문자
2. 레시피 재료 - ~255 자리의 문자
3. 레시피 용량 - 355, 471, 591 의 열거형 문자
4. 레시피 온도 - isIced
5. 레시피 공개 여부 - isPublic
6. 레시피 재료의 수 - 1 개 이상 20개 이하
    1. 각 재료의 이름 - 1 ~ 20 자리의 문자
    2. 각 재료의 색상 - 디자인 시안에 포함되어 있는 N 개의 열거형 문자
    3. 각 재료의 용량 - 컵의 최대 용량을 초과하지 않는 선에서 최대값
```

이러한 ***비정형 데이터*** 를 순수하게 조건문으로 제어하는 것은 너무나 비효율 적이라고 생각했습니다.

또한, 이러한 값들이 수많은 컴포넌트를 오가면서 ***props drilling*** 을 일으키는 것도 큰 문제였습니다.

따라서 이러한 문제점을 해결할 수 있는 라이브러리가 필요했습니다.

<hr>

### 4.2. 비교 대상 및 선택 동기

1. reduxt-toolkit
2. react-hook-form

위 선택지 중에서 더욱 좁은 범위헤서 활동하는 ***react-hook-form*** 을 선택하게 되었습니다.

더욱, 구체적으로 표현하자면 <br>

1. 비제어 컴포넌트 방식으로 구현되어, 컴포넌트의 깊이와 무관하게 이를 감지하고 변경시킬 수 있습니다. 또 이러한 과정에서 랜더링이 일어나지 않습니다.
2. 각 데이터의 state 가 동기화 되어 한 장소에서 관리할 수 있습니다.
3. useState hook 에서 받은 Error 를 통해 각 섹션의 에러를 감지하고 상태관리를 적용할 수 있습니다.
    ```
    error.recipe?.message
    ```
4. handleSubmit 함수를 통해서 사용자가 에러 없는 form 을 제출했음을 확인할 수 있습니다. 이를 통해 적은 양의 코드로도 효율적으로 validation 을 수행할 수 있습니다.

> redux 를 선택하지 않은 이유는 <br>
    >

<hr>

### 4.3. 후기

사용법을 익히면서, 사용 단계 별로 새로운 input 이 보이는 Cupick 의 UI 에 적용하는 데 생각보다 어려웠던 것 같습니다.

해당 과정에서 ***평균 깊이가 3 이상*** 에서 심하면 ***4 ~ 5 깊이*** 정도의 심한 props drilling 이 식별되었습니다.

처음에는 이 부분을 redux-tookkit 전역 상태관리 라이브러리를 사용하려고 했으나, 다음의 이유로 포기하게 되었습니다.

1. 전역 상태관리를 도입할 정도로 많은 정보가 나오지 않고 있는 점
2. 리펙터링을 통해서 이를 해결하는 과정을 시도하지 않았던 점
3. 상태관리 라이브러리의 수가 많아져서 발생 되는 심한 의존성이 걱정 되었던 점